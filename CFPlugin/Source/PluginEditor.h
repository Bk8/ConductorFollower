/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#ifndef __PLUGINEDITOR_H_D516F0C3__
#define __PLUGINEDITOR_H_D516F0C3__

#include <boost/fusion/include/for_each.hpp>

#include "ScoreFollower/FollowerStatus.h"
#include "ScoreFollower/FollowerOptions.h"
#include "ScoreFollower/StatusEvents.h"

#include "MotionTracker/EventQueue.h"

#include "Visualizer/Data.h"
#include "Visualizer/Visualizer.h"

#include "../JuceLibraryCode/JuceHeader.h"
#include "../JuceLibraryCode/JucePluginCharacteristics.h"
#include "PluginProcessor.h"

#include "Components/StatusWidget.h"
#include "Components/OptionWidget.h"

using namespace cf::ScoreFollower;

//==============================================================================
/**
*/
class CfpluginAudioProcessorEditor
	: public AudioProcessorEditor
	, public ChangeListener
	, public Button::Listener
{
public:
    CfpluginAudioProcessorEditor (CfpluginAudioProcessor* ownerFilter);
    ~CfpluginAudioProcessorEditor();

    //==============================================================================
    // This is just a standard Juce paint method...
    void paint (Graphics& g);

public:
	void changeListenerCallback(ChangeBroadcaster *source);
	void buttonClicked(Button *button);

	CfpluginAudioProcessor* ownerFilter;

private: // UI functions
	void BuildUI();
	void InitializeWidgets();
	void LayoutWidgets();

	template<typename TWidgets, typename TSource>
	void InitializeOneWidgetSet(TWidgets & widgets, TSource source)
	{
		WidgetInitializer<TWidgets> initializer(widgets);
		boost::fusion::for_each(source->map(), initializer);
	}

	template<cf::Status::Level Level, typename TWidgets>
	void LayoutOneWidgetSet(int & yPos, int height, TWidgets & widgets)
	{
		std::vector<Component *> components;
		
		auto allCollector = make_widget_collector<cf::Status::Advanced>(components);
		boost::fusion::for_each(widgets, allCollector);
		std::for_each(components.begin(), components.end(),
			[this](Component * c)
			{
				removeChildComponent(c);
			});

		components.clear();
		auto showCollector = make_widget_collector<Level>(components);
		boost::fusion::for_each(widgets, showCollector);
		std::for_each(components.begin(), components.end(),
			[&](Component * c)
			{
				addAndMakeVisible(c);
				c->setBounds(padding, yPos, optionsWidth, height);
				yPos += height + padding;
			});
	}

	template<cf::Status::Level Level>
	int LayoutAutomaticWidgets()
	{
		int yPos = 0;
		LayoutOneWidgetSet<Level>(yPos, statusWidgetHeight, statusWidgets);
		LayoutOneWidgetSet<Level>(yPos, optionWidgetHeight, optionWidgets);
		return yPos;
	}

private: // UI constants

	// Making dynamic UIs with Juce is retarded,
	// so we just do this...
	static int const padding = 6;

	static int const optionsWidth = 330;
	static int const optionWidgetHeight = 40;
	static int const statusWidgetHeight = 30;

	static int const visualizationWidth = 640;
	static int const visualizationHeight = 480;

	static int const totalWidth = optionsWidth + visualizationWidth + 2 * padding;
	static int const totalHeight = visualizationHeight;

private: // UI Data

	typedef Status::FollowerStatus::transformed<StatusWidget>::type FollowerStatusWidgets;
	FollowerStatusWidgets statusWidgets;

	typedef Options::FollowerOptions::transformed<StatusWidget>::type FollowerOptionWidgets;
	FollowerOptionWidgets optionWidgets;

	TextButton expandButton;
	bool expanded;

	cf::Visualizer::Visualizer::Ptr visualizer_;

private: // Event stuff
	void ConsumeEvent(cf::MotionTracker::Event const & e);
	void ConsumeEvent(cf::ScoreFollower::StatusEvent const & e);

	cf::Visualizer::DataBufferPtr visualizationData_;
	boost::shared_ptr<cf::MotionTracker::EventQueue> eventQueue_;
};


#endif  // __PLUGINEDITOR_H_D516F0C3__
