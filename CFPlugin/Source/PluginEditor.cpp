/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

#include "Components/WidgetHelpers.h"

//==============================================================================
CfpluginAudioProcessorEditor::CfpluginAudioProcessorEditor (CfpluginAudioProcessor* ownerFilter)
    : AudioProcessorEditor (ownerFilter)
	, ownerFilter(ownerFilter)
	, visualizer_(cf::Visualizer::Visualizer::Create())
	, latestFrameId_(-1)
{
    // This is where our plugin's editor size is set.
    setSize (700, 800);
	BuildUI();
	ownerFilter->changeBroadcaster.addChangeListener(this);
}


void
CfpluginAudioProcessorEditor::BuildUI()
{
	{
		using namespace cf::ScoreFollower::Status;
		auto status = ownerFilter->StatusReader();
		WidgetInitializer<FollowerStatusWidgets> initializer(statusWidgets);
		boost::fusion::for_each(status->map(), initializer);

		std::vector<Component *> components;
		WidgetCollector<std::vector<Component *> > collector(components);
		boost::fusion::for_each(statusWidgets, collector);

		int yPos = 0;
		int const height = 30;
		for(auto it = components.begin(); it != components.end(); ++it) {
			addAndMakeVisible(*it);
			(*it)->setBounds(0, yPos, 300, height);
			yPos += height;
		}
	}

	/**************************/
	{
		using namespace cf::ScoreFollower::Options;
		auto options = ownerFilter->OptionsReader();
		WidgetInitializer<FollowerOptionWidgets> initializer(optionWidgets);
		boost::fusion::for_each(options->map(), initializer);

		std::vector<Component *> components;
		WidgetCollector<std::vector<Component *> > collector(components);
		boost::fusion::for_each(optionWidgets, collector);

		int yPos = 0;
		int const height = 50;
		for(auto it = components.begin(); it != components.end(); ++it) {
			addAndMakeVisible(*it);
			(*it)->setBounds(300, yPos, 300, height);
			yPos += height;
		}
	}

	addAndMakeVisible(visualizer_.get());
	visualizer_->setBounds(0, 300, 700, 500);
	visualizer_->SetSize(700, 500);
}

CfpluginAudioProcessorEditor::~CfpluginAudioProcessorEditor()
{
	ownerFilter->changeBroadcaster.removeChangeListener(this);
	// The automatic child components are in the fusion::maps,
	// and deleteAllChildren() should NOT be called!
}

//==============================================================================
void CfpluginAudioProcessorEditor::paint (Graphics& g)
{
	g.fillAll (Colours::white);
	
	auto visualizationData = ownerFilter->VisualizationData();
	if (visualizationData) {
		auto reader = visualizationData->GetReader();
		if (reader->frameId() != latestFrameId_) {
			latestFrameId_ = reader->frameId();
			visualizer_->UpdateData(*reader);
		}	
	}
}

void
CfpluginAudioProcessorEditor::changeListenerCallback(ChangeBroadcaster * /*source*/)
{
	{
		auto status = ownerFilter->StatusReader();
		WidgetUpdater<FollowerStatusWidgets> updater(statusWidgets);
		boost::fusion::for_each(status->map(), updater);
	}

	{
		auto options = ownerFilter->OptionsWriter();
		WidgetUpdater<FollowerOptionWidgets> updater(optionWidgets);
		boost::fusion::for_each(options->map(), updater);
	}

	visualizer_->repaint();
}
